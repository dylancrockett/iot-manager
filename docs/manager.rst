.. Documentation for the IoTManager class,
   including examples of how to use it and
   what methods it provides

###########################
iot-manager Usage Reference
###########################

The following contains information on the IoTManager module's
classes such as their inputs and member methods,
how to connect to a the IoTManager using clients, and how to use the
IoTManager class to interface with connected IoT Clients.

*********************************
iot-manager Classes Documentation
*********************************

.. _Manager:

Manager Class Documentation
==============================

This section details how the Manager_ class is written
and what parameters and member methods it has. ::

   class iot_manager.Manager(**params, **kwargs)

**Parameters**

* | **valid_types** (list_) -
  |  A list of strings_ that are the type of a type of device which a client can identify
     as, below is an example of such a list that could be passed.

   ::

    types = ["light", "lock", "thermostat"]

* | **ssl_context** (Optional[ssl_context_])[None] -
  |  A TLS/SSL wrapper context for securing socket communications over unsecured networks.

* | **host** (Optional[string_])["127.0.0.1"] -
  |  The host IP the server is running on. For example "0.0.0.0" on windows and "127.0.0.1"
     on Linux.

* | **connection_port** (Optional[int_])[8595] -
  |  The port that clients will use to connect to the Manager_ with.

* | **max_workers** (Optional[int_])[16] -
  |  The max number of ThreadPoolExecutor workers that the Manager_ can put to use concurrently.

* | **heartbeat_rate** (Optional[int_])[60] -
  |  The frequency, in seconds, at which the Manager_ will check the heartbeat of all
     connected clients.

* | **backlogged_connections** (Optional[int_])[10] -
  |  The number of backlogged connections the listening socket can have before it refuses
     new clients.

* | **logging_id** (Optional[string_])["[Manager]"] -
  |  Changes the ID of the logger used by the Manager_ in the logging messages.

* | **logging_level** (Optional[logging.LEVEL])[logging.INFO] -
  |  Changes the level of logging output generated by the Manager_.

**Class Members**

* | **host(**\ string_\ **)**
  |  The IP of the host connection, always '0.0.0.0'.

* | **port(**\ int_\ **)**
  |  The port clients will use to connect to the Manager. Changing this value will not
     update the connection port so it should be treated as read-only.

* | **logger(**\ logging.Logger_\ **)**
  |  The logger object used by the Manager_ to do logging.

* | **heartbeat_rate(**\ int_\ **)**
  |  The frequency, in seconds, at which the Manager will check the heartbeat of all
     connected clients.

**Class Methods**

* | **send_all(**\ data[bytes_]\ **)**
  |  Sends the given data to all clients connected to the Manager_.

* | **send_type(**\ device_type[string_], data[bytes_]\ **)**
  |  Sends the given data to all clients connected to the Manager_ of a specified device_type.

* | **send(**\ unique_id[string_], data[bytes_]\ **)**
  |  Sends the given data to a client connected to the Manager_ with a matching UUID.

* | **send_all_string(**\ string[string_]\ **)**
  |  Sends the given string to all clients connected to the Manager_.

* | **send_type_string(**\ device_type[string_], string[string_]\ **)**
  |  Sends the given string to all clients connected to the Manager_ of a specified device_type.

* | **send(**\ unique_id[string_], string[string_]\ **)**
  |  Sends the given string to a client connected to the Manager_ with a matching UUID.

* | **get_client_data()**
  | Returns a list_ of dicts_ which contain each connected client's information. each
    dict is formatted like the following example

   ::

    {
        "uuid": (uuid of the client connection)[str],
        "type": (client's type)[str],
        "data": (client's data)[dict]
    }


.. _Client:

Client Class Documentation
==========================

This section details what members and member methods the Client
class has. ::

   class iot_manager.Client(**params, **kwargs)

**Parameters**

* | **connection(**\ socket_\ **)**
  | An active socket which is connected to a device, used to communicate with the device.

* | **address(**\ tuple_\ **)**
  | The address info of the client as a (IP, PORT) pair.

**Class Members**

* | **connection_lock(**\ RLock_\ **)**
  | A RLock object used to prevent multiple threads from accessing the Client's underlying
    socket connection at the same time. Useful for executing a send and recv pair without
    the Manager_'s listener accessing the socket while awaiting a response. Example:

.. code-block:: python

   # acquire the lock
   with client.connection_lock:
      # request some data
      client.send_string("get_data")

      # get some data (10 second timeout)
      response = client.recv_string(10)
   # release the lock


* | **data(**\ Data_\ **)**
  | A object that stores the client's data retrieved from the get_data_ method.

**Class Methods**

.. _end:

* | **end(**\ raise_exception[boolean_](False)\ **)**
  | Calling this method will end the client's socket connection with the server after
    sending the client the "end\n" message. Finally raising a ConnectionEnd_ error
    when finished if raise_exception is set to true.

.. _send:

* | **send(**\ bytes_\ **)**
  | Similar to the socket.sendall_ method, however rather than raising exceptions it will
    return None instead of the # of bytes sent.

.. _recv:

* | **recv(**\ timeout[int_](15) **)**
  | Similar to the socket.recv_ method, however rather than raising exceptions it will
    return None instead of the data received. Timeout is the delay before a socket timeout
    is triggered in seconds (The data received from this method is a bytes_ object)

* | **send_string(**\ string[string_]\ **)**
  | Uses the send_ method to send a given string to the client.

* | **recv_string(**\ timeout[int_](15) **)**
  | Uses the recv_ method to recv a string from a client.

.. _get_data:

* | **get_data(**\ timeout[int_](15) **)**
  | Initiates a handshake procedure with the client, asking for the clients information
    such as UUID, type, and data. This handshake is imitated by the Manager_ when the client
    first connects and does not need to be used after, but can if needed if edit's to the
    Client_'s data are made while a ongoing connection exists. Can raise a ConnectionEnd_ and
    InvalidInfo_ exception if the client fails to answer or provides invalidly formatted data.

.. _heartbeat:

* | **heartbeat(**\ timeout[int_](15) **)**
  | A method used by the Manager_'s heartbeat checking protocol to see if clients are
    still connected and responsive. It is a handshake procedure similar to the get_data_
    method which has no real use outside of the Manager_ but is provided for convenience.
    Can raise a ConnectionEnd_ exception if the client fails to complete the handshake correctly.

* | **return_data()**
  | An alternative to using Data_'s get_ method.

**Class Errors**

.. _ConnectionEnd:

* | **ConnectionEnd(**\ Exception_\ **)**
  | An exception raised whenever the end_ method is called by the client. This error
    can be raised by the Client get_data_ and heartbeat_ methods, as well as by the user
    explicitly calling the end_ method.

.. _InvalidInfo:

* | **InvalidInfo(**\ Exception_\ **)**
  | An exception raised by the Client_'s get_data_ method whenever the client provides data
    in an invalid format which cannot be read by the server.

.. _Data:

Data Class Documentation
========================

This section details what members and member methods the Data
class has. ::

   class iot_manager.Data(**params, **kwargs)

**Parameters**

* | **client_uuid(**\ string_\ **)**
  | The UUID of the Client_ used for identifying a given device or sub process on a device.
    Devices can have many Client_ connections open with the server at once as long as each
    has its own UUID. Must be 32 bytes long or the server will reject the Client_, and if
    another Client_ is already connected to the server with the same UUID the old Client_'s
    connection will be terminated and replaced by the new Client_.

* | **client_type(**\ string_\ **)**
  | The type of device the Client_ is. Must match one of the types provided when the Manager_
    was created or the Client_ will be rejected from connecting to the Manager_.

* | **client_data(**\ dict_\ **)**
  | Custom data send by the Client_ which is converted to a dict_ when received by the Manager.

**Class Members**

* | **uuid(**\ string_\ **)**
  | The Client_'s UUID.

* | **type(**\ string_\ **)**
  | The Client_'s type.

* | **data(**\ dict_\ **)**
  | The Client_'s data.

**Class Methods**

.. _get:

* | **get()**
  | Returns the Data_ object as a dict_ so that it can be passed to other applications such as
    a web server.

.. _list: https://docs.python.org/3/library/stdtypes.html#typesseq-list
.. _int: https://docs.python.org/3/library/stdtypes.html#int
.. _strings: https://docs.python.org/3/library/stdtypes.html#str
.. _string: https://docs.python.org/3/library/stdtypes.html#str
.. _boolean: https://docs.python.org/3/reference/datamodel.html#object.__bool__
.. _dict: https://docs.python.org/3/tutorial/datastructures.html#dictionaries
.. _dicts: https://docs.python.org/3/tutorial/datastructures.html#dictionaries
.. _socket: https://docs.python.org/3/library/socket.html#module-socket
.. _tuple: https://docs.python.org/3.3/tutorial/datastructures.html#tuples-and-sequences
.. _ssl_context: https://docs.python.org/3/library/ssl.html#ssl.SSLContext
.. _logging.Logger: https://docs.python.org/2/library/logging.html#logging.Logger
.. _bytes: https://docs.python.org/3/library/stdtypes.html#bytes-objects
.. _RLock: https://docs.python.org/2/library/threading.html#rlock-objects
.. _Exception: https://docs.python.org/3/library/exceptions.html#Exception
.. _socket.sendall: https://docs.python.org/2/library/socket.html#socket.socket.sendall
.. _socket.recv: https://docs.python.org/2/library/socket.html#socket.socket.recv
.. _bytearray: https://docs.python.org/3.1/library/functions.html#bytearray

**************
Manager Events
**************

This section explains how to make make use of events provided by the Manager, this
including how to define your own events as well as examples showing you how they can work.

**Event Explanation**
Events are a way of handling connections and messages from clients to the server. For example
**on_connect** handlers will trigger when a client connects so the user can do additional connection
management when the device connects to the manager. Another example is the **on_message** handler which
allows the user to handle messages from a client to the server.

| **Global Events**
| Below is a list of global events that the Manager provides, these will trigger when any client meets the condition.

* | **on_connect(**\ client[Client_]\ **)**
  |  This event will trigger and run the code it contains when a new client connects to the Manager_. It is provided
  |  the Client_ object of the client which has just connected.

* | **on_message(**\ client[Client_], message[bytearray_]\ **)**
  |  This event will trigger and run the code it contains when a client sends a message to the Manager_. It is provided
  |  the Client_ object of the client who sent the message as well as the message in bytearray_ form.

| **Type Specific Events**
| Below is an explanation on how to define device specific event handlers. Type Specific Events trigger under the same
| conditions as Global Events, but only when the type of device specified is the one triggering the event.
| For example the type specific event **on_message_test** will trigger only when a client with type "test" sends
| a message to the server.

* | **on_connect_[type](**\ client[Client_]\ **)**
  |  This event will trigger and run the code it contains when a new client connects to the Manager_. It is provided
  |  the Client_ object of the client which has just connected. Triggers only when client of matching type is the
  |  event triggered.

* | **on_message_[type](**\ client[Client_], message[bytearray_]\ **)**
  |  This event will trigger and run the code it contains when a client sends a message to the Manager_. It is provided
  |  the Client_ object of the client who sent the message as well as the message in bytearray_ form. Triggers only
  |  when client of matching type is the event triggered.


***************************
Manager Connection Protocol
***************************

This section details how to write a client that is able to connect to the IoTManager
properly. As well giving as a basic client written in python which can connect to a
IoT Manager.

The following steps occur when a client connects to the IoTManager an

1. The Manager sends the client the **getinfo** command as the leading byte **0B00000001** or **\x01**.
2. The client must respond to the manager with a string containing the following information separated by a
   "##" delimiter.
    * UUID - A 36 char UUID string used to identify a client. Must be unique as clients that have
      conflicting UUIDs will cause one another to disconnect.
    * Type - The type of the device the client is, must match a value from the **valid_types** list_
      entered when the Manager was created, if it does not match one of those values the client will
      be rejected.
    * Device Data - Extra data that can be supplied by the device, will be formatted into a dictionary when
      being read by the Manager. Below  is an example of how this data should be formatted when sent
      from the client: ::

         data = '{ "key_1": "data_1", "key_2": "data_2" }'

      The example above would be converted to the following dictionary when read by the IoT Manager: ::

         data = {
            "key_1": "data_1",
            "key_2": "data_2"
         }

   This above information must be formatted into a single line with each piece of information
   separated by a **:**. The following string is an example of a valid response to the
   **getinfo** command. ::

      response = '1862cfe1-5dab-4d8e-a946-50d6728f830f##light##{ "key_1": "data_1", "key_2": "data_2" }'
3. The client will now be accepted by the Manager but an additional step must be taken to ensure
   a continued connection.
4. The Manager will send out a heartbeat request signified by the command **heart** as the byte **0B00000010**
   or **\x02**), the client must respond to this command by sending back the matching **beat** command (as a string_).
   If the client fails to respond to the manager within 15 seconds the client's connection to the manager will be
   terminated.

####################
iot-manager Examples
####################

*****************************
Example Client Code in Python
*****************************
The following code will connect successfully to a running Manager, it does nothing but connect
and print out every command received from the server.

.. literalinclude:: basic_client.py
   :language: python

Manager Example Code
====================
The following is an example showing how to instantiate the Manager as well as send commands using
both events and the send function. The example uses a flask web server as the interface with the Manager
and shows how the Manager can be used to create a basic IoT Web App. Below is both the flask server
and required html file.

.. literalinclude:: manager_example.py
   :language: python

.. literalinclude:: example_index.html
   :language: html


